\documentclass[letterpaper,10pt]{article}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{alltt}
\usepackage{color}
\usepackage{url}
\usepackage{geometry}

% set margins to 0.75in
\geometry{textheight=9.5in, textwidth=7in}
%letter is 11 x 8.5 w/out margins

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\newcommand{\toc}{\tableofcontents}

%\usepackage{hyperref}

\def\name{CS444 Group1}


%pull in the necessary preamble matter for pygments output
\input{pygments.tex}

%% The following metadata will show up in the PDF properties
% \hypersetup{
%   colorlinks = false,
%   urlcolor = black,
%   pdfauthor = {\name},
%   pdfkeywords = {cs311 ``operating systems'' files filesystem I/O},
%   pdftitle = {CS 311 Project 1: UNIX File I/O},
%   pdfsubject = {CS 311 Project 1},
%   pdfpagemode = UseNone
% }

\parindent = 0.0 in
\parskip = 0.1 in

\begin{document}

%\tableofcontents

\section{WriteUp 1}

\subsection{Command Log}
{\bfseries Logging into OS2}\\
1). ssh os2.engr.oregonstate.edu\\\\
{\bfseries Creating Group Folder}\\
1). cd /scratch/fall/2018\\
2). mkdir group1\\\\
{\bfseries Cloning Repository}\\
1). cd /scratch/fall2018/group1/\\
2). git clone git://git.yoctoproject.org/linux-yocto-3.19\\
3). git checkout tags/v3.19.2\\\\
{\bfseries Copying Files}\\
1). cp -R /scratch/files. /scratch/fall2018/group1\\\\
{\bfseries Setting Up Environment}\\
1). cd /scratch/fall2018/group1/\\
2). source environment-setup-i586-poky-linux\\
3). qemu-system-i386 -gdb tcp::5501 -S -nographic -kernel bzImage-qemux86.bin -drive\\ file=core-image-lsb-sdk-qemux86.ext4,if=virtio -enable-kvm -net none -usb -localtime\\
--no-reboot --append "root=/dev/vda rw console=ttyS0 debug"\\

This will hang, which it should; to unhang the process, follow the steps below.

{\bfseries Debugging}\\
Start another terminal in OS2 and run the following commands:\\
1). gdb\\
2). target remote tcp:5501\\
3). continue\\\\
{\bfseries Part 2: Testing Toolchain}\\
1). cd /scratch/fall2018/group1/linux-yocto-3.19\\
2). cp /scratch/files/config-3.19.2-yocto-standard .config\\
2). make -j4 all\\\\
{\bfseries Compiling Latex}\\
1). cd /scratch/fall2018/group1/Writeup1\\
2). make TRG=writeup1\\
\subsection{qemu Explanation}
{\bfseries Qemu Flags}\\
1). {\textbf{-S:}} Do not start the CPU at startup.\\
2). {\textbf{-nographic:}} Disable graphical output so that QEMU is a command line only application.\\
3). {\textbf{-kernel:}} Use a bzImage as the kernel, in our case it is using the Intel x86 architecture.\\
4). {\textbf{-drive file=core-image-lsb-sdk-qemux86.ext4,if=virtio:}} this is used to open an image used file descriptors\\
5). {\textbf{-enable-kvm:}} Allows full virtualization support.\\
6). {\textbf{-net none:}} There is no on-board NIC.\\
7). {\textbf{-usb:}} Enables USB driver.\\
8). {\textbf{-localtime:}} ??\\
9). {\textbf{--no-reboot:}} exit instead of rebooting\\
10). {\textbf{--append "root=/dev/vda rw console=ttyS0 debug":}} ??\\\\

\subsection{Concurrency}
\begin{enumerate}
\item The objective of concurrency is to understand how to syncrenize operations between two tasks.
\item We use pthreads for multithreading and mutexes for critical sections. One buffer, two threads (plus the main thread), and one mutex one mutex played a role in producing and consuming jobs. Details regarding the role of each are described below:
\begin{description}
\item[Buffer] The buffer is circular FIFO queue, containing jobs awaiting to be consumed. The buffer's starting and ending points are marked by \texttt{jhead} and \texttt{jtail} variables. Produced jobs are appended to the circular queue, incrementing and wrapping \texttt{jtail}. Consumed jobs are removed out of the cicrular queue, incrementing and wrapping \texttt{jhead}. \\\\
The buffer has a limit defined by \texttt{NUM_JOBS} preprocessor. Once \texttt{jtail} reaches the limit, that is one less than \texttt{jhead}, the producer stops creating jobs until space becomes available again.
\item[Producer] The producer thread is a continuous while loop, which does the following:
\begin{enumerate}
\item Acquire mutex via \texttt{pthread_mutex_lock}.\
\item Check if the jobs queue is not full. If the queue is full, simply unlock the mutex and continue the loop.
\item Create a job with randomized wait time and number values. The randomization is achieved by \texttt{rdrand} if supported by platform or \texttt{mt19937} if not.
\item Append job to the queue, incrementing and wrapping \texttt{jtail}.
\item Release the mutex via \texttt{pthread_mitex_unlock}.
\end{enumerate}
\item[Consumer] The consumer thread is also a continuous while loop, which does the following:
\begin{enumerate}
\item Acquire mutex
\item Check if queue is not empty. If empty, release the mutex and continue the loop.
\item Get job at \texttt{jhead}.
\item Print out the number value of job.
\item Copy job wait time to a seperate variable, \texttt{dt}.
\item Increment and wrap \texttt{jhead}.
\item Release the mutex
\item Sleep for await time indicated at \texttt{dt}.
\end{enumerate}
\end{description}
\item 
\item Although I had previous experiance with mutexes and multithreading, I did learn that concurrency can as well be achived with semaphores.
\end{enumerate}

\subsection{Version Control}

\subsection{Work Log}

\end{document}
