\documentclass[letterpaper,10pt]{article}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{alltt}
\usepackage{color}
\usepackage{url}
\usepackage{geometry}
\usepackage[normalem]{ulem}
\useunder{\uline}{\ul}{}

% set margins to 0.75in
\geometry{textheight=9.5in, textwidth=7in}
%letter is 11 x 8.5 w/out margins

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\newcommand{\toc}{\tableofcontents}

%\usepackage{hyperref}

\def\name{CS444 Group1}


%pull in the necessary preamble matter for pygments output
\input{pygments.tex}

%% The following metadata will show up in the PDF properties
% \hypersetup{
%   colorlinks = false,
%   urlcolor = black,
%   pdfauthor = {\name},
%   pdfkeywords = {cs311 ``operating systems'' files filesystem I/O},
%   pdftitle = {CS 311 Project 1: UNIX File I/O},
%   pdfsubject = {CS 311 Project 1},
%   pdfpagemode = UseNone
% }

\parindent = 0.0 in
\parskip = 0.1 in

\begin{document}

%\tableofcontents

\section{WriteUp 1}

%\iffalse

\subsection{Command Log}
{\bfseries Logging into OS2}\\
\begin{enumerate}
\item ssh os2.engr.oregonstate.edu\\\\
\end{enumerate}
{\bfseries Creating Group Folder}\\
\begin{enumerate}
\item cd /scratch/fall/2018\\
\item mkdir group1\\\\
\end{enumerate}
{\bfseries Cloning Repository}\\
\begin{enumerate}
\item cd /scratch/fall2018/group1/\\
\item git clone git://git.yoctoproject.org/linux-yocto-3.19\\
\item git checkout tags/v3.19.2\\\\
\end{enumerate}
{\bfseries Copying Files}\\
\begin{enumerate}
\item cp -R /scratch/files. /scratch/fall2018/group1\\\\
\end{enumerate}
{\bfseries Setting Up Environment}\\
\begin{enumerate}
\item cd /scratch/fall2018/group1/\\
\item source environment-setup-i586-poky-linux\\
\item qemu-system-i386 -gdb tcp::5501 -S -nographic -kernel bzImage-qemux86.bin -drive\\ file=core-image-lsb-sdk-qemux86.ext4,if=virtio -enable-kvm -net none -usb -localtime\\
--no-reboot --append "root=/dev/vda rw console=ttyS0 debug"\\
\end{enumerate}
This will hang, which it should; to unhang the process, follow the steps below.\\

{\bfseries Debugging}\\
\begin{enumerate}
\item Start another terminal in OS2 and run the following commands:\\
\item gdb\\
\item target remote tcp:5501\\
\item continue\\\\
\end{enumerate}
{\bfseries Part 2: Testing Toolchain}\\
\begin{enumerate}
\item cd /scratch/fall2018/group1/linux-yocto-3.19\\
\item cp /scratch/files/config-3.19.2-yocto-standard .config\\
\item make -j4 all\\\\
\end{enumerate}
{\bfseries Compiling Latex}\\
\begin{enumerate}
\item cd /scratch/fall2018/group1/Writeup1\\
\item make TRG=writeup1\\
\end{enumerate}
\subsection{qemu Explanation}
{\bfseries Qemu Flags}\\
\begin{enumerate}
\item {\textbf{-S:}} Do not start the CPU at startup.\\
\item {\textbf{-nographic:}} Disable graphical output so that QEMU is a command line only application.\\
\item {\textbf{-kernel:}} Use a bzImage as the kernel, in our case it is using the Intel x86 architecture.\\
\item {\textbf{-drive file=core-image-lsb-sdk-qemux86.ext4,if=virtio:}} this is used to open an image used file descriptors\\
\item {\textbf{-enable-kvm:}} Allows full virtualization support.\\
\item {\textbf{-net none:}} There is no on-board NIC.\\
\item {\textbf{-usb:}} Enables USB driver.\\
\item {\textbf{-localtime:}} Legacy option that's currently undocumented. Replaced by -rtc "localtime", which lets the TRC start at the current UTC time.\\
\item {\textbf{--no-reboot:}} exit instead of rebooting\\
\item {\textbf{--append "root=/dev/vda rw console=ttyS0 debug":}} Enables debug text to display on the user's terminal\\\\
\end{enumerate}

%\fi

\subsection{Concurrency}
\begin{enumerate}
\item The objective of concurrency is to understand how to synchronize operations between two tasks.
\item We use pthreads for multi-threading and mutexes for critical sections. One buffer, two threads (plus the main thread), and one mutex are involved in producing and consuming jobs. Details regarding the role of each are described below:
\begin{description}
\item[Buffer] The buffer is a circular FIFO queue, containing jobs awaiting to be consumed. The buffer's starting and ending points are marked by \texttt{jhead} and \texttt{jtail} variables. Produced jobs are appended to the circular queue, incrementing and wrapping \texttt{jtail}. Consumed jobs are removed out of the cicrular queue, incrementing and wrapping \texttt{jhead}.

The buffer has a limit defined by \texttt{NUM\_JOBS} preprocessor. Once \texttt{jtail} reaches the limit, that is one less than \texttt{jhead}, the producer stops creating jobs until space becomes available again.
\item[Producer] The producer thread is a continuous while loop, which does the following:
\begin{enumerate}
\item Acquire mutex via \texttt{pthread\_mutex\_lock}.
\item Check if the jobs queue is not full. If the queue is full, simply unlock the mutex and continue the loop.
\item Create a job with randomized wait time and number values. The randomization is achieved by \texttt{rdrand} if supported by platform or \texttt{mt19937} if not.
\item Append job to the queue, incrementing and wrapping \texttt{jtail}.
\item Release the mutex via \texttt{pthread\_mutex\_unlock}.
\end{enumerate}
\item[Consumer] The consumer thread is also a continuous while loop, which does the following:
\begin{enumerate}
\item Acquire mutex.
\item Check if queue is not empty. If empty, release the mutex and continue the loop.
\item Get job at \texttt{jhead}.
\item Print out the number value of job.
\item Copy job wait time to a seperate variable, \texttt{dt}.
\item Increment and wrap \texttt{jhead}.
\item Release the mutex.
\item Sleep for await time indicated at \texttt{dt}.
\end{enumerate}
\end{description}
\item In order to validate concurrency, we printed out every time a job was produced and every time a job was about to be consumed. A small delay was added after producing a job, to ensure that a job can be consumed while jobs are being produced. Once the buffer fills up, the producer waits for consumer to consume a job.
\item Although I, Anton, had previous experience with mutexes and multithreading, I did learn that concurrency can as well be achieved with semaphores.
\end{enumerate}

\subsection{Version Control}
\begin{table}[]
\begin{tabular}{llllll}
\textbf{V} & \textbf{Date} & \textbf{Commit Message} & \textbf{Modified Files} & \textbf{Number of Added Lines} & \textbf{Number of Deleted Lines} \\
1 & Oct 8, 2018 & Uploaded concurrency & 2 & 225 & 0 \\
2 & Oct 8, 2018 & Changed permissions & 4 & 0 & 0 \\
3 & Oct 9, 2018 & Setup write up Tex & 2 & 126 & 0 \\
4 & Oct 9, 2018 & Added Pygments & 1 & 98 & 0 \\
5 & Oct 9, 2018 & Included pygments to preamble & 1 & 8 & 6 \\
6 & Oct 9, 2018 & First successful compile of writeup1 & 6 & 329 & 2 \\
7 & Oct 9, 2018 & Updated gitignore & 5 & 3 & 326 \\
8 & Oct 9, 2018 & Setup write up & 1 & 10 & 20 \\
9 & Oct 9, 2018 & Added git attributes for enforce EOL & 1 & 7 & 0 \\
10 & Oct 9, 2018 & EOL deal & 2 & 1 & 2 \\
11 & Oct 9, 2018 & Trying to fix TEX compiling & 2 & 79 & 1 \\
12 & Oct 9, 2018 & Added sections to writeup & 3 & 8 & 81 \\
13 & Oct 9, 2018 & Added the write up for Command Logs and for the Qemu flags & 11 & 97 & 10 \\
14 & Oct 10, 2018 & Work on concurrency writeup & 8 & 30 & 56 \\
15 & Oct 10, 2018 & More work concurrency write up & 2 & 12 & 7 \\
16 & Oct 10, 2018 & Made concurrency use circular queue & 1 & 41 & 34 \\
17 & Oct 10, 2018 & Fixed concurrency print type & 1 & 9 & 6 \\
18 & Oct 10, 2018 & Renamed Assignment1 folder to Concurrency and finished my writeup & 5 & 25 & 18 \\
19 & Oct 11, 2018 & Disabled BIB command in makefile & 2 & 3 & 3 \\
20 & Oct 11, 2018 & Added compile instructions & 1 & 26 & 3 \\
21 & Oct 11, 2018 & README adjustments & 1 & 3 & 3 \\
22 & Oct 12, 2018 & corrected name & 1 & 1 & 1 \\
23 & Oct 12, 2018 & Explain -localtime and -append root=/dev/vda rw console=ttSO debug & 1 & 2 & 2 \\
24 & Oct 12, 2018 & Add work log. & 1 & 6 & 0
\end{tabular}
\end{table}
\subsection{Work Log}
\begin{description}
    \item[Getting Acquainted]
    The "Getting Acquainted" section was broken up between the group members to more evenly balance the work. In week two we started and completed the core of the assignment, which was to set up a working version of the yocto kernel where we tested both the emulator and the toolchain. This process was faster than expected since everything surprisingly just worked. At the beginning of week three we started working on the write up, where each person was assigned a specific section to complete sometime before the due date.
    \item[Concurrency]
    We completed the "Concurrency" section on week two while at the library. This took a couple of hours to write a working prototype, debug it, and add specific features such as buffer limits, addition speed, etc... mainly for verifying functionality. We followed a loose group coding technique where one person would write the code and the other would make suggestions, corrections, and look up different documentations as needed. This made the coding process go very smoothly and we were able to finish relatively quickly.
                \end{description}

\end{document}
